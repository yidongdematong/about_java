## 结构型模式
这些模式关注对象之间的组合和关系，旨在解决如何构建灵活且可复用的类和对象结构。

### 代理模式（proxy pattern)

在代理模式中，一个类代表另一个类的功能，这种类型的设计模式属于结构型模式。

代理模式通过引入一个代理对象来控制对原对象的访问。代理对象在客户端和目标对象之间充当中介，负责将客户端的请求转发给目标对象，同时可以在转发请求前后进行额外的处理。
在代理模式中，创建具有现有对象的对象，以便向外界提供功能接口。


#### 目的

为其他对象提供一种代理以控制对这个对象的访问。



#### 主要解决的问题

代理模式解决的是在直接访问某些对象时可能遇到的问题，例如对象创建成本高、需要安全控制或远程访问等。

#### 使用场景
当需要在访问一个对象时进行一些控制或额外处理时

#### 实现方式
- 增加中间层：创建一个代理类，作为真是真实对象的中间层。
- 代理与真实对象组合：代理类持有真实对象的引用，并在访问时进行控制。
#### 关键代码

- 代理类： 实现与真实对象相同的接口，并添加额外的控制逻辑
- 真实对象：实际执行任务的对象。

#### 应用实例
- 快捷方式：windows系统中的快捷方式作为文件或程序的代理
- 角色扮演：孙悟空作为高翠兰的代理，猪八戒无法区分。
- 代售点：购买火车票时，代售点作为火车站的代理。
- 支票：作为银行账户资金的代理，控制资金的访问。
- Spring aop:使用代理模式来实现面向切面编程。
#### 优点

- 职责分离：代理模式将访问控制与业务逻辑分离。
- 扩展性：可以灵活的添加额外的功能或控制。
- 智能化：可以智能的处理访问请求，如延迟加载、缓存等
#### 缺点
- 性能开销：增加了代理层可能会影响请求的处理速度
- 实现复杂性：某些类型的代理模式实现起来可能较为负责。
#### 使用建议

- 根据具体需求选择合适的代理类型，如远程代理、虚拟代理、保护代理等。
- 确保代理类与真实对象接口一致，以便客户端透明的使用代理。

#### 注意点
- 与适配器模式的区别：适配器模式改变接口，而代理模式不改变接口。
- 与装饰器模式的区别：装饰器模式用于增强功能，代理模式用于控制访问。

#### 接口

主要涉及以下几个核心角色：

- 抽象主题（subject）：声明真实主题和代理共有的接口。
- 真实主题（real subject）：实现了抽象主题接口，是代理对象所代表的真实对象。客户端直接访问真实主题，但在某些情况下，可以通过代理主题来访问。
- 代理（proxy）：实现了抽象主题接口，并持有对真实主题的引用。代理主题通常在真实主题的基础上提供一些额外的功能，例如延迟加载、权限控制、日志记录等。
- 客户端（client）：使用抽象主题接口来操作真实主题或代理主题，不需要知道具体是哪一个实现类。
#### Java 代理模式分类
- 静态代理（Static Proxy）
- 动态代理（Dynamic Proxy）
   - JDK 动态代理（基于接口）
   - CGLIB 动态代理（基于继承）
#### 实例
##### static proxy 静态代理
```
// 1. 抽象主题
interface UserService {
    void deleteUser(String userId);
}

// 2. 真实主题
class RealUserService implements UserService {
    @Override
    public void deleteUser(String userId) {
        System.out.println("正在删除用户: " + userId);
    }
}

// 3. 代理类
class UserServiceProxy implements UserService {
    private UserService realService;

    public UserServiceProxy(UserService realService) {
        this.realService = realService;
    }

    @Override
    public void deleteUser(String userId) {
        // 权限检查
        if (!"admin".equals(userId)) {
            System.out.println("权限不足，无法删除用户");
            return;
        }
        // 调用真实对象
        realService.deleteUser(userId);
    }
}

// 4. 客户端使用
public class Main {
    public static void main(String[] args) {
        UserService real = new RealUserService();
        UserService proxy = new UserServiceProxy(real);

        proxy.deleteUser("user123");   // 权限不足
        proxy.deleteUser("admin");     // 成功删除
    }
}
```
优点：职责清晰，可扩展性强

缺点：每个真实主题都需要一个代理类，代码冗余
#####  JDK 动态代理示例（基于接口）
使用 java.lang.reflect.Proxy 和 InvocationHandler
```
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

// 接口（必须有）
interface PaymentService {
void pay(double amount);
}

// 真实实现
class AlipayService implements PaymentService {
@Override
public void pay(double amount) {
System.out.println("通过支付宝支付: " + amount + " 元");
}
}

// 通用日志代理处理器
class LoggingHandler implements InvocationHandler {
private Object target;

    public LoggingHandler(Object target) {
        this.target = target;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("【日志】开始调用方法: " + method.getName());
        Object result = method.invoke(target, args);
        System.out.println("【日志】方法调用结束");
        return result;
    }
}

// 客户端
public class DynamicProxyDemo {
public static void main(String[] args) {
PaymentService real = new AlipayService();

        // 创建代理
        PaymentService proxy = (PaymentService) Proxy.newProxyInstance(
            real.getClass().getClassLoader(),
            real.getClass().getInterfaces(),
            new LoggingHandler(real)
        );

        proxy.pay(99.9); // 自动添加日志
    }
}

```
要求：目标类必须实现至少一个接口

优点：无需为每个类写代理，通用性强

##### CGLIB 动态代理（适用于无接口类）
需要引入 CGLIB 库（如 Maven 依赖）：
```
<dependency>
    <groupId>cglib</groupId>
    <artifactId>cglib</artifactId>
    <version>3.3.0</version>
</dependency>
```
```
import net.sf.cglib.proxy.Enhancer;
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;
import java.lang.reflect.Method;

// 没有实现接口的类
class OrderService {
    public void createOrder(String orderId) {
        System.out.println("创建订单: " + orderId);
    }
}

// CGLIB 代理拦截器
class OrderInterceptor implements MethodInterceptor {
    @Override
    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
        System.out.println("【CGLIB】前置处理: " + method.getName());
        Object result = proxy.invokeSuper(obj, args); // 调用父类方法
        System.out.println("【CGLIB】后置处理");
        return result;
    }
}

public class CglibProxyDemo {
    public static void main(String[] args) {
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(OrderService.class);
        enhancer.setCallback(new OrderInterceptor());

        OrderService proxy = (OrderService) enhancer.create();
        proxy.createOrder("ORD12345");
    }
}
```